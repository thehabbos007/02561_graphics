<html>
  <header>
    <meta charset="UTF-8" />
    <link rel="stylesheet" href="../milligram.css" />
  </header>
  <body>
    <p>Oi</p>

    <canvas id="view" width="512" height="512"></canvas>

    <script src="../common/webgl-utils.js"></script>
    <script src="../common/initShaders.js"></script>
    <script src="../common/MV.js"></script>

    <script id="vertex-shader" type="x-shader/x-vertex">
      attribute vec4 a_position;
      varying vec4 v_position;

      void main() {
        v_position = a_position;
        gl_Position = a_position;
        gl_Position.z = 1.0;
      }
    </script>
    <script id="fragment-shader" type="x-shader/x-fragment">
      precision mediump float;
      uniform samplerCube u_skybox;
      uniform mat4 u_viewDirectionProjectionInverse;

      varying vec4 v_position;
      void main() {
        vec4 t = u_viewDirectionProjectionInverse * v_position;
        gl_FragColor = textureCube(u_skybox, normalize(t.xyz / t.w));
      }
    </script>
    <script>
      const cubemap = [
        "http://www.student.dtu.dk/~s185126/02561/textures_7/cm_left.png",
        "http://www.student.dtu.dk/~s185126/02561/textures_7/cm_right.png",
        "http://www.student.dtu.dk/~s185126/02561/textures_7/cm_top.png",
        "http://www.student.dtu.dk/~s185126/02561/textures_7/cm_bottom.png",
        "http://www.student.dtu.dk/~s185126/02561/textures_7/cm_back.png",
        "http://www.student.dtu.dk/~s185126/02561/textures_7/cm_front.png",
      ];
      const canvas = document.getElementById("view");
      let gl;

      let loadImages = async (imageLocations) => {
        const imagePromises = imageLocations.map(async (imgLoc) => {
          const img = new Image();
          img.crossOrigin = "anonymous";
          img.src = imgLoc;
          await img.decode();
          return img;
        });
        return await Promise.all(imagePromises);
      };
      function init() {
        gl = WebGLUtils.setupWebGL(canvas);
        if (!gl) {
          alert("WebGL isnâ€™t available");
        }

        gl.enable(gl.CULL_FACE);
        gl.enable(gl.DEPTH_TEST);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        gl.clearColor(0.3921, 0.5843, 0.9294, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);

        let program = initShaders(gl, "vertex-shader", "fragment-shader");
        gl.useProgram(program);

        var positionLocation = gl.getAttribLocation(program, "a_position");
        var skyboxLocation = gl.getUniformLocation(program, "u_skybox");
        var viewDirectionProjectionInverseLocation = gl.getUniformLocation(
          program,
          "u_viewDirectionProjectionInverse"
        );

        var positionBuffer = gl.createBuffer();
        gl.enableVertexAttribArray(positionLocation);
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        const positions = new Float32Array([
          -1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1,
        ]);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

        gl.activeTexture(gl.TEXTURE0);
        let texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);

        // gl.generateMipmap(gl.TEXTURE_CUBE_MAP);

        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

        loadImages(cubemap).then((res) =>
          res.forEach((img, i) => {
            const imgTarget = gl.TEXTURE_CUBE_MAP_POSITIVE_X + i;
            gl.activeTexture(gl.TEXTURE0);
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
            gl.texImage2D(imgTarget, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, img);
          })
        );

        requestAnimationFrame(render);
      }
      const render = () => {
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        gl.drawArrays(gl.TRIANGLES, 0, 1 * 6);
        requestAnimationFrame(render);
      };
      window.onload = init;
    </script>
  </body>
</html>
